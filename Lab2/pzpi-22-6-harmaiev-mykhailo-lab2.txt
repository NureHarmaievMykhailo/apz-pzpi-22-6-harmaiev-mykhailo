Міністерство освіти та науки України
Харківський національний університет радіоелектроніки



Кафедра ПІ



Звіт
з лабораторної роботи №2
з дисципліни “Архітектура програмного забезпечення”

на тему: « РОЗРОБКА ПРОГРАМНОЇ АРХІТЕКТУРИ, СТВОРЕННЯ ТА ВІДЛАГОДЖЕННЯ ПРОГРАМНОГО КОДУ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ»


Виконав
ст. гр. ПЗПІ-22-6 
Гармаєв Михайло Саянович
Перевірив
ст. викл. Сокорчук І. П.



Харків 2025 р

1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	25.06.2025	0.1	Створено розділи «Історія змін», «Завдання»
2	25.06.2025	0.2	Створено основні розділи
3	26.06.2025	0.3	Змінено підрозділи 3.1, 3.2 та 3.3 документу Vision & Scope
4	26.06.2025	0.4	Створено Додатки А та Б

2	ЗАВДАННЯ

•	Потрібно розробити серверну / back-end частину програмної системи.
•	Проаналізуйте завдання (додаток В).
•	Виконайте контрольні завдання.
•	Відкрийте створений на попередній лабораторній роботі репозиторій GitHub.
•	Створіть у репозиторії директорію Lab2 та текстовий файл з описом інженерних рішень у цій частині проєкту.
•	Зафіксуйте кожну внесену зміну командою git commit з відповідним коментарем та фіксуйте цією командою усі наступні зміни у проєкті.
•	Створіть у директорії Lab2 піддиректорію для програмного коду.
•	Створіть програмний код, завантажте його у створену піддиректорію, зафіксуйте внесені у репозиторій зміни. Виконайте функціональне тестування створеного програмного коду та створіть відеозапис цього тестування тривалістю 7-10 хвилин з усними поясненнями процесу тестування.
•	Завантажте створений відеозапис тестування YouTube канал для вашого облікового запису в домені @nure.ua
•	Створіть для завантаженого запису його хронологічний опис.
•	Оформіть звіт у форматі pdf та завантажте його на навчальну платформу https://dl.nure.ua/
•	У коментарях до завантаженого звіту вкажіть посилання на відеозапис тестування у вашому каналі YouTube.
3	ОПИС ВИКОНАНОЇ РОБОТИ
Система SmartRoad має клієнт-серверну архітектуру. Серверна частина реалізована на платформі ASP.NET Core Web API (.NET 8) з використанням Entity Framework Core для доступу до даних. Для зберігання інформації застосовується реляційна база даних SQL Server, що працює у Docker-контейнері. Безпечна аутентифікація користувачів здійснюється за допомогою JWT (JSON Web Token). Система інтегрується з IoT-сенсорами, які встановлені на дорожніх ділянках і збирають дані про стан покриття, що дозволяє проводити моніторинг і генерувати сповіщення у разі критичних ситуацій.
Основні модулі серверної частини
1. Авторизація та автентифікація
•	Реєстрація та вхід користувачів (адміністратори, оператори та звичайні користувачі).
•	Використання JWT для безпечної аутентифікації та авторизації.
•	Керування ролями (Admin, Worker, User) і правами доступу.
2. Модуль управління дорожніми ділянками
•	Додавання, редагування та видалення об’єктів дорожньої інфраструктури.
•	Перегляд стану конкретної ділянки на основі даних сенсорів.
3. Модуль сенсорів та збору даних
•	Інтеграція з IoT-сенсорами, що збирають показники:
	температуру,
	вологість,
	стан покриття (наявність вибоїн, льоду).
•	Збереження історії даних у базі даних.
•	Передача показників у серверну частину для подальшого аналізу.
4. Модуль аналітики та сповіщень
•	Автоматичне створення сповіщень при критичних показниках.
•	Управління статусом сповіщень (активне / вирішене).
•	Формування зведених звітів та прогнозів (у наступних релізах – із застосуванням ШІ).
5. Модуль профілю користувача
•	Управління інформацією про користувача.
•	Зміна ролі та даних облікового запису.

Специфікація прикладного програмного інтерфейсу (API)
Сутність Auth (авторизація)
POST /api/Auth/login — вхід користувача.
POST /api/Auth/register — реєстрація нового користувача.
Сутність Users (користувачі)
GET /api/Users — отримати список користувачів.
GET /api/Users/{id} — отримати користувача за ID.
POST /api/Users/register — додати користувача.
POST /api/Users/login — автентифікація користувача.
PUT /api/Users/{id}/role — оновлення ролі користувача.
DELETE /api/Users/{id} — видалити користувача.
Сутність RoadSections (ділянки доріг)
GET /api/RoadSections — отримати список ділянок доріг.
GET /api/RoadSections/{id} — отримати ділянку за ID.
POST /api/RoadSections — створити нову ділянку.
PUT /api/RoadSections/{id} — оновити дані ділянки.
DELETE /api/RoadSections/{id} — видалити ділянку.
Сутність Sensors (сенсори)
GET /api/Sensors — отримати список сенсорів.
GET /api/Sensors/{id} — отримати сенсор за ID.
POST /api/Sensors — додати новий сенсор.
PUT /api/Sensors/{id} — оновити інформацію про сенсор.
DELETE /api/Sensors/{id} — видалити сенсор.
Сутність SensorData (дані сенсорів)
GET /api/SensorData — отримати дані сенсорів.
GET /api/SensorData/{id} — отримати дані за ID.
POST /api/SensorData — додати нові показники.
PUT /api/SensorData/{id} — оновити показники.
DELETE /api/SensorData/{id} — видалити показники.
GET /api/SensorData/report — отримати зведений звіт.
Сутність Alerts (повідомлення)
GET /api/Alerts — отримати список сповіщень.
GET /api/Alerts/{id} — отримати сповіщення за ID.
POST /api/Alerts — створити нове сповіщення.
POST /api/Alerts/generate — згенерувати сповіщення.
PUT /api/Alerts/{id} — оновити сповіщення.
PUT /api/Alerts/{id}/resolve — позначити сповіщення як вирішене.
DELETE /api/Alerts/{id} — видалити сповіщення.

4	ВИСНОВКИ
У ході виконання лабораторної роботи було розроблено серверну частину системи SmartRoad, яка реалізує клієнт-серверну архітектуру з використанням ASP.NET Core Web API та SQL Server у середовищі Docker. Для взаємодії з базою даних застосовано Entity Framework Core, що дозволило зручно реалізувати CRUD-операції для основних сутностей: користувачів, дорожніх ділянок, сенсорів, даних сенсорів та сповіщень.
Було побудовано ER-модель та UML-діаграми (Use Case, Deployment, Component, Activity), які описують структуру та функціонування системи. Реалізовано REST API, що забезпечує повноцінну взаємодію клієнтів із сервером, а також протестовано його роботу за допомогою Swagger UI.
У результаті отримано робочий прототип серверної частини, який може масштабуватися та доповнюватися новими функціональними модулями. Система забезпечує безпечну авторизацію користувачів за допомогою JWT, інтегрується з IoT-сенсорами для збору даних про стан дорожнього покриття та дозволяє оперативно формувати сповіщення про небезпечні ситуації.
 
Додаток А
Посилання на відео та хронологічний опис


 
Додаток Б
Графічні матеріали
 
Рисунок Б.1 - ER-діаграма бази даних системи
 
Рисунок Б.2 - UML діаграма розгортання (Deployment Diagram)
 
Рисунок Б.3 - UML діаграма прецедентів (Use Case Diagram)
 
Рисунок Б.4 - UML діаграма компонентів (Component Diagram)
Додаток В 
Програмний код
В.1 Обробка критичного повідомлення 
GitHub репозиторій: https://github.com/NureHarmaievMykhailo/apz-pzpi-22-6-harmaiev-mykhailo/tree/main/Lab2/pzpi-22-6-harmaiev-mykhailo-lab2 
1.  public async Task GenerateCriticalAlertsAsync()
2.  {
3.      var criticalData = await _context.SensorData
4.          .Include(sd => sd.Sensor)
5.          .ThenInclude(s => s.RoadSection)
6.          .Where(sd => sd.Parameter == "Температура" && sd.DataValue < -5)
7.          .ToListAsync();
8.  
9.      foreach (var data in criticalData)
10.     {
11.         bool exists = await _context.Alerts.AnyAsync(a =>
12.             a.RoadSectionID == data.Sensor.RoadSectionID &&
13.             a.AlertType == "Температура" &&
14.             !a.IsResolved);
15. 
16.         if (!exists)
17.         {
18.             var alert = new Alert
19.             {
20.                 RoadSectionID = data.Sensor.RoadSectionID,
21.                 AlertType = "Температура",
22.                 Message = $"Температура {data.DataValue}°C. Ризик обледеніння.",
23.                 CreatedDate = DateTime.UtcNow,
24.                 IsResolved = false
25.             };
26.             _context.Alerts.Add(alert);
27.         }
28.     }
29. 
30.     await _context.SaveChangesAsync();
31. }
32. }


В.2 Резервне копіювання користувацьких даних
#!/bin/bash
# Full backup of SmartRoad database (SQL Server in Docker)

DB_NAME="SmartRoad"
DB_USER="sa"
DB_PASS="************"
DB_HOST="localhost"
DB_PORT="1433"
BACKUP_DIR="backup"
DATE=$(date +%F_%H-%M-%S)
BACKUP_FILE="/var/opt/mssql/backup/${DB_NAME}_backup_${DATE}.bak"

mkdir -p "$BACKUP_DIR"

# Виконуємо повний бекап через sqlcmd всередині контейнера "sqlserver"
docker exec sqlserver /opt/mssql-tools18/bin/sqlcmd \
  -S $DB_HOST,$DB_PORT -U $DB_USER -P $DB_PASS -Q \
"BACKUP DATABASE [$DB_NAME] TO DISK = N'$BACKUP_FILE' WITH INIT, COMPRESSION, STATS=10;"

if [ $? -eq 0 ]; then
  echo "Backup successful: $BACKUP_FILE"
else
  echo "Backup failed, error: $?"
fi

