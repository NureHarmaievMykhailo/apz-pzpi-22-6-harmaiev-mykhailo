Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра ПІ



Звіт
з практичної роботи №1
з дисципліни “Архітектура програмного забезпечення”
Тема роботи: «Шаблон (патерн) проєктування ПЗ»

Виконав:                                                                  		 ст. гр. ПЗПІ-22-6 
 Гармаєв М.С.
Викладач:                                                                             Сокорчук І.П.






Харків
2024 р
1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
01.04.2025
1.0
Створено файл, визначено структуру. Створено розділ «Завдання»
2
03.04.2025
1.1
Створено розділ: «Опис виконаної роботи»
3
08.04.2025
1.2
Завершено написання розділу «Опис виконаної роботи». Створення розділу «Висновки»
4
10.04.2025
1.3
Створено розділи із додатками. Завершено оформлення звіту.

2 ЗАВДАННЯ
Дослідити породжувальний шаблон проєктування Factory Method, надати опис його структури, призначення, переваг та недоліків, приклади реалізації шаблону засобами мови програмування C#. Підготувати презентацію та відеозапис доповіді.


3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1  Вступ
   Сучасна розробка програмного забезпечення стикається з багатьма викликами, серед яких основними є забезпечення гнучкості, масштабованості, підтримуваності та повторного використання коду. У цих умовах шаблони проєктування – це перевірені рішення, що дозволяють впоратися з типовими проблемами архітектури програм. Одним із ключових породжувальних шаблонів є Factory Method (Фабричний метод), який широко використовується у програмній інженерії.
   Factory Method дозволяє інкапсулювати логіку створення об'єктів і делегувати її підкласам. Такий підхід забезпечує низький рівень зв'язності між класами і підвищує розширюваність системи. У цій доповіді ми детально розглянемо суть патерна, його призначення, структуру, варіанти використання, переваги та недоліки, а також підкріпимо матеріал прикладами реалізації на мові програмування C#.

3.2  Визначення
   Factory Method (Фабричний метод) – це шаблон проєктування, що належить до категорії породжувальних. Його головною ідеєю є делегування створення об'єктів підкласам, дозволяючи класам визначати, який саме об’єкт необхідно створити без жорсткої прив’язки до конкретних класів.
   Іншими словами, Factory Method визначає загальний інтерфейс для створення об’єкта, але дозволяє підкласам вирішувати, який саме клас буде створено. Це забезпечує високу гнучкість у розширенні програми та дотримання принципів SOLID, зокрема принципу відкритості/закритості (Open/Closed Principle).

3.3  Структура патерна
   Шаблон проєктування Factory Method реалізує принцип інверсії залежностей, дозволяючи об'єктам створювати інші об'єкти без прив'язки до їхніх конкретних класів. Щоб досягти цього, патерн пропонує чітко визначену структуру з чотирма основними складовими. Розглянемо кожен з компонентів докладно:
1) Product (Продукт)
     Product — це абстрактний клас або інтерфейс, який оголошує спільний інтерфейс для всіх об'єктів, що можуть бути створені фабрикою. Цей інтерфейс визначає методи, які повинні реалізувати всі конкретні продукти.
     Мета компонента забезпечити єдиний контракт для всіх продуктів та дозволити клієнтам використовувати продукти, не знаючи їх конкретного типу (приклад застосування див. Додаток В).
2) ConcreteProduct (Конкретний продукт)
     ConcreteProduct — це конкретна реалізація інтерфейсу або базового класу Product. Кожен конкретний продукт реалізує функціональність, визначену в Product, і може мати свою унікальну поведінку.
     Мета компонента реалізувати конкретну логіку, відповідну продукту. Бути повністю замінним із іншими продуктами, які реалізують той самий інтерфейс (приклад застосування див. Додаток В).
3) Creator (Factory) (Творець або Фабрика)
     Creator — це абстрактний клас або інтерфейс, який оголошує фабричний метод (зазвичай з іменем на кшталт CreateProduct), що повертає об'єкт типу Product. У деяких випадках Creator також може містити іншу логіку, що використовує створений продукт — наприклад, бізнес-логіку, що залежить лише від загального інтерфейсу продукту, при цьому не знаючи його конкретного типу. Таким чином, Factory Method дозволяє розширювати програму без змін у наявному коді Creator-а.
     Мета компонента визначити загальну поведінку, яку можна розділити між усіма конкретними творцями. А також визначити інтерфейс для створення об’єкта, залишаючи вибір конкретного класу підкласам (приклад застосування див. Додаток В).
4) ConcreteCreator (Конкретна фабрика)
     ConcreteCreator — це клас, що розширює Creator та реалізує фабричний метод, повертаючи конкретний тип продукту (ConcreteProduct). У цьому класі відбувається безпосереднє створення екземпляру певного продукту.
   Мета компонента реалізувати специфічну логіку створення об'єкта певного класу. Ізолювати процес створення від решти програми (приклад застосування див. Додаток В).

3.4  Застосування
   Шаблон Factory Method є універсальним та широко застосовним у програмному забезпеченні. Його сила – у гнучкості створення об'єктів без прив’язки до конкретних класів. Розглянемо типові сценарії, в яких Factory Method є особливо корисним. 
1) Коли клас не може передбачити тип об’єктів, які йому потрібно створити. У деяких випадках програма повинна створювати об’єкти, тип яких буде визначатися під час виконання – наприклад, на основі введених користувачем параметрів або конфігурації. У таких випадках Factory Method дозволяє делегувати створення конкретного об’єкта класам-нащадкам, які знають, який саме об’єкт потрібно створити.
У системі обробки платіжних транзакцій, залежно від вибраного способу оплати (картка, PayPal, криптовалюта), створюється відповідна стратегія обробки (див. Додаток В).
2) Коли створення об’єктів делегується підкласам для забезпечення розширюваності. Якщо очікується, що система буде розширюватися новими типами об’єктів у майбутньому, Factory Method дозволяє додавати нові реалізації без зміни існуючого коду. Таким чином, дотримується принцип відкритості/закритості (Open/Closed Principle).
У графічному редакторі можуть з'являтися нові фігури — коло, квадрат, полігон, тощо. Кожна фігура реалізує один інтерфейс, і нові фігури можна легко додавати (див. Додаток В).
3) Коли програма повинна бути незалежною від способу створення, складання та представлення об’єктів. Це ключовий принцип інверсії залежностей. Програма повинна оперувати абстракціями, а не конкретними реалізаціями. Factory Method дозволяє реалізувати цю ідею: об’єкти створюються через абстрактні інтерфейси, а конкретні реалізації підставляються на рівні фабрик.
У додатку для зберігання документів можуть бути різні способи зберігання — в базу даних, у файл або в хмару (див. Додаток В).
4) У фреймворках, коли потрібно надати користувачам можливість розширювати компоненти без зміни ядра. Factory Method часто використовується у фреймворках і бібліотеках, де важливо надати розширюваність. Замість жорсткого кодування способів створення об'єктів, фреймворк викликає метод, який користувач може перевизначити.
У фреймворку для тестування можна перевизначити метод створення тестового об’єкта (див. Додаток В).
3.5  Переваги та Недоліки патерна
   Переваги:
   1) Однією з ключових переваг шаблону Factory Method є інкапсуляція процесу створення об'єктів. Клієнтський код не знає, який саме клас буде створено, і працює виключно через абстракції. Це дозволяє змінювати або розширювати створювані класи без внесення змін до основної логіки програми. Такий підхід знижує зв’язаність компонентів і сприяє більш чистій архітектурі.
   2) Factory Method також ідеально реалізує принцип відкритості/закритості (Open/Closed Principle). Це означає, що система може легко розширюватися новими типами об'єктів (продуктів) без змін у вже написаному коді. Щоб додати новий тип продукту, достатньо створити новий підклас, який реалізує необхідну поведінку – і при цьому вся інша система залишиться недоторканою.
   3) Крім того, шаблон полегшує тестування та підтримку коду. Завдяки інтерфейсам і абстракціям, можна легко підміняти конкретні реалізації продуктів на фейкові або мок-об’єкти під час модульного тестування. Це особливо важливо у великих проектах, де контроль над залежностями має критичне значення.
   4) Ще однією перевагою є гнучкість у використанні різних реалізацій інтерфейсів. Підкласи можуть реалізовувати власні варіанти фабричного методу, що дає змогу в кожному конкретному випадку створювати найбільш відповідний об’єкт. Такий підхід дозволяє змінювати поведінку програми, просто підставивши інший підклас-фабрику, без необхідності змінювати клієнтський код.

Недоліки:
   Попри переваги, використання Factory Method має і свої недоліки. 
   1) Одним із основних є збільшення кількості класів у проєкті. Кожного разу, коли потрібно створити новий тип продукту, доводиться створювати окрему реалізацію класу-фабрики. У великих системах це може призвести до суттєвого зростання кількості класів, що ускладнює навігацію, супровід і загальне розуміння проєкту.
   2) Ще один недолік полягає в ускладненні структури коду. Для початківців та навіть для деяких досвідчених розробників архітектура, побудована на основі Factory Method, може здатися заплутаною, оскільки ланцюг викликів і залежностей між фабриками та продуктами часто не є очевидним. Це ускладнює читання коду та розуміння, яка саме реалізація буде використана у конкретний момент.
   3) Крім того, у простих випадках застосування патерна може бути надмірним. Наприклад, якщо програма має лише один або два типи продуктів, які не будуть змінюватися чи розширюватися, впровадження фабричного методу лише ускладнить реалізацію без реальної потреби. У таких ситуаціях пряме створення об’єктів через оператор new є цілком прийнятним і навіть бажаним, адже воно забезпечує простоту та прозорість коду.
3.6  Висновки
   Factory Method – це потужний інструмент об'єктно-орієнтованого проєктування, який дозволяє створювати об'єкти гнучким, масштабованим і безпечним способом. Завдяки делегуванню створення об'єктів підкласам, можна досягти високого рівня абстракції та зменшити залежність між компонентами системи. Цей шаблон особливо корисний у великих програмних системах, де необхідно підтримувати багато варіантів об'єктів, які мають спільний інтерфейс або базовий клас. Водночас варто зважати на складність структури, яку може принести надмірне використання цього шаблону в простих сценаріях.
   Загалом, Factory Method є ключовим шаблоном, знання і розуміння якого є важливим для будь-якого програміста, який прагне писати чистий, гнучкий і підтримуваний код.


ДОДАТОК А
Посилання на GitHub репозиторій: https://github.com/NureHarmaievMykhailo/apz-pzpi-22-6-harmaiev-mykhailo/tree/main/Pract1 
Відеозапис доповіді на YouTube: https://www.youtube.com/watch?v=zixNiCOSYyc 
Хронологічний опис доповіді:
00:00-01:17 - Вступ
01:17-01:56 - Визначення та суть патерна Factory method
01:57-04:21 - Структура патерна Factory Method
04:22-05:17 - Застосування Factory Method
05:18-06:22 - Приклад використання шаблону на мові С# №1
06:23-06:43 - Застосування Factory Method
06:44-07:59 - Приклад використання шаблону на мові С# №2
08:00-08:27 - Застосування Factory Method
08:28-09:24 - Приклад використання шаблону на мові С# №3
09:26-09:50 - Застосування Factory Method
09:51-11:25 - Переваги шаблону Factory Method
11:28-12:42 - Недоліки шаблону Factory Method
12:43-13:35 - Висновки 

ДОДАТОК Б

Рисунок Б.1 – Зміст першого слайда: Вступ.

Рисунок Б.2 – Зміст другого слайда: Визначеннята суть шаблону Factory Method.

Рисунок Б.3 – Зміст третього слайда: Структура патерна та його складові.
Рисунок Б.4 – Зміст четвертого слайда: Застосування Factory Method.


Рисунок Б.5 – Зміст п’ятого слайда: Перший приклад застосування патерна.

Рисунок Б.6 – Зміст шостого слайда: Другий приклад застосування патерна.


Рисунок Б.7 – Зміст сьомого слайда: Третій приклад застосування патерна.
Рисунок Б.8 – Зміст восьмого слайда: Переваги Factory Method.


Рисунок Б.9 – Зміст дев’ятого слайда: Переваги Factory Method

Рисунок Б.10 – Зміст десятого слайда: Недоліки Factory Method

Рисунок Б.11 – Зміст одинадцятого слайда: Висновки


ДОДАТОК В
Приклади використання:
1) Абстрактний клас або інтерфейс Product:
1     public interface ITransport
2     {
3         void Deliver();
4     }

2) Конкретна реалізація інтерфейсу або базового класу Product – ConcreteProduct:
1     public class Truck : ITransport
2     {
3         public void Deliver()
4         {
5             Console.WriteLine("Доставка вантажівкою.");
6         }
7     }
8     public class Ship : ITransport
9     {
10         public void Deliver()
11         {
12             Console.WriteLine("Доставка кораблем.");
13         }
14     }

3) Абстрактний клас або інтерфейс Creator:
1     public abstract class Logistics
2     {
3         public void PlanDelivery()
4         {
5             ITransport transport = CreateTransport();
6             transport.Deliver();
7         }
8     
9         public abstract ITransport CreateTransport();
10    }

4) Клас ConcreteCreator, що розширює Creator:
1     public class RoadLogistics : Logistics
2     {
3         public override ITransport CreateTransport()
4         {
5             return new Truck();
6         }
7     }
8     public class SeaLogistics : Logistics
9     {
10         public override ITransport CreateTransport()
11         {
12             return new Ship();
13         }
14     }

5) У системі обробки платіжних транзакцій, залежно від вибраного способу оплати (картка, PayPal, криптовалюта), створюється відповідна стратегія обробки:
1     public interface IPayment
2     {
3         void ProcessPayment();
4     }
5     
6     public class CardPayment : IPayment
7     {
8         public void ProcessPayment()
9         {
10            Console.WriteLine("Обробка оплати карткою.");
11        }
12    }
13    
14    public class PayPalPayment : IPayment
15    {
16        public void ProcessPayment()
17        {
18            Console.WriteLine("Оплата через PayPal.");
19        }
20    }
21    
22    public abstract class PaymentFactory
23    {
24        public abstract IPayment CreatePayment();
25    }
26    
27    public class CardPaymentFactory : PaymentFactory
28    {
29        public override IPayment CreatePayment() => new CardPayment();
30    }
31    
32    public class PayPalPaymentFactory : PaymentFactory
33    {
34        public override IPayment CreatePayment() => new PayPalPayment();
35    }

6) У графічному редакторі можуть з'являтися нові фігури — коло, квадрат, полігон, тощо. Кожна фігура реалізує один інтерфейс, і нові фігури можна легко додавати
1     public interface IShape
2     {
3         void Draw();
4     }
5     
6     public class Circle : IShape
7     {
8         public void Draw() => Console.WriteLine("Малюю коло.");
9     }
10    
11    public class Square : IShape
12    {
13        public void Draw() => Console.WriteLine("Малюю квадрат.");
14    }
15    
16    public abstract class ShapeFactory
17    {
18        public abstract IShape CreateShape();
19    }
20    
21    public class CircleFactory : ShapeFactory
22    {
23        public override IShape CreateShape() => new Circle();
24    }
25    
26    public class SquareFactory : ShapeFactory
27    {
28        public override IShape CreateShape() => new Square();
29    }

7) У додатку для зберігання документів можуть бути різні способи зберігання — в базу даних, у файл або в хмару:
1     public interface IStorage
2     {
3         void Save(string content);
4     }
5     
6     public class FileStorage : IStorage
7     {
8         public void Save(string content)
9         {
10            Console.WriteLine($"Зберігаю у файл: {content}");
11        }
12    }
13    
14    public class CloudStorage : IStorage
15    {
16        public void Save(string content)
17        {
18            Console.WriteLine($"Зберігаю в хмару: {content}");
19        }
20    }
21    
22    public abstract class StorageFactory
23    {
24        public abstract IStorage CreateStorage();
25    }

8) У фреймворку для тестування можна перевизначити метод створення тестового об’єкта:
1     public abstract class TestCase
2     {
3         public void RunTest()
4         {
5             object testObject = CreateTestObject();
6             Console.WriteLine("Тестування об’єкта: " + testObject.GetType().Name);
7         }
8     
9         protected abstract object CreateTestObject();
10    }
11    
12    public class UserTest : TestCase
13    {
14        protected override object CreateTestObject()
15        {
16            return new User(); // створення користувача
17        }
18    }


